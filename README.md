# üöÄ Plantilla Microservicio .NET - Docker Profesional

Una plantilla completa y profesional para crear microservicios en .NET 8 con Docker, dise√±ada para ser **completamente configurable** y **listo para producci√≥n**.

## ‚ú® Caracter√≠sticas Principales

### üê≥ **Docker Profesional**

- **Multi-stage builds** para optimizaci√≥n
- **Variables din√°micas** para configuraci√≥n autom√°tica
- **Health checks** integrados
- **Usuario no-root** para seguridad
- **Logging estructurado** con Serilog

### üîß **Configuraci√≥n Autom√°tica**

- **Script de inicializaci√≥n** que renombra todo autom√°ticamente
- **Variables de entorno** din√°micas
- **Configuraci√≥n por ambiente** (Development/Production)
- **Generaci√≥n autom√°tica** de contrase√±as seguras

### üèóÔ∏è **Arquitectura Limpia**

- **Clean Architecture** implementada
- **CQRS** con MediatR
- **Dependency Injection** configurado
- **Repository Pattern** con Unit of Work

### üìä **Monitoreo y Logging**

- **Serilog** con logging estructurado
- **Seq** para visualizaci√≥n de logs
- **Prometheus** para m√©tricas
- **Grafana** para dashboards
- **Health checks** autom√°ticos

### üîí **Seguridad**

- **JWT Authentication** configurado
- **HTTPS** listo para producci√≥n
- **CORS configurado profesionalmente** con configuraci√≥n por ambiente
- **Rate limiting** integrado

## üöÄ Inicio R√°pido

### üéØ **¬øQu√© es esta Plantilla?**

Esta es una **plantilla enterprise-grade** para crear microservicios en .NET 8 siguiendo los principios de **Clean Architecture** y **CQRS**. Es una soluci√≥n completa y profesional que incluye:

- ‚úÖ **Clean Architecture** implementada con separaci√≥n clara de capas
- ‚úÖ **CQRS (Command Query Responsibility Segregation)** con MediatR
- ‚úÖ **Entity Framework Core** configurado para acceso a datos
- ‚úÖ **Docker profesional** con multi-stage builds y optimizaci√≥n
- ‚úÖ **Logging estructurado** con Serilog y Seq
- ‚úÖ **JWT Authentication** configurado y listo
- ‚úÖ **CORS configurado profesionalmente** por ambiente
- ‚úÖ **Scripts de inicializaci√≥n autom√°tica** con renombrado inteligente
- ‚úÖ **Configuraci√≥n por ambiente** (Development/Production)
- ‚úÖ **Health checks** y monitoreo integrado
- ‚úÖ **Rate limiting** y seguridad avanzada

### üìã **Prerrequisitos**

Antes de comenzar, aseg√∫rate de tener instalado:

- ‚úÖ **.NET 8.0 SDK** o superior
- ‚úÖ **Docker Desktop** (versi√≥n 20.10 o superior)
- ‚úÖ **Git** (versi√≥n 2.30 o superior)
- ‚úÖ **Make** (opcional, para usar comandos abreviados)
- ‚úÖ **Familiaridad con Clean Architecture y CQRS**
- ‚úÖ **Entity Framework Core** (incluido en la plantilla)

#### **Instalar Docker Desktop**

**Windows:**

```bash
# Descargar desde: https://www.docker.com/products/docker-desktop
# Ejecutar el instalador y seguir las instrucciones
```

**macOS:**

```bash
# Descargar desde: https://www.docker.com/products/docker-desktop
# Arrastrar Docker.app a Applications
```

**Linux (Ubuntu/Debian):**

```bash
# Actualizar repositorios
sudo apt update

# Instalar dependencias
sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release

# Agregar clave GPG de Docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Agregar repositorio de Docker
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Instalar Docker
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io

# Agregar usuario al grupo docker
sudo usermod -aG docker $USER

# Iniciar Docker
sudo systemctl start docker
sudo systemctl enable docker
```

#### **Instalar .NET 8.0 SDK**

**Windows:**

```bash
# Descargar desde: https://dotnet.microsoft.com/download/dotnet/8.0
# Ejecutar el instalador
```

**macOS:**

```bash
# Con Homebrew
brew install dotnet

# O descargar desde: https://dotnet.microsoft.com/download/dotnet/8.0
```

**Linux (Ubuntu/Debian):**

```bash
# Agregar repositorio de Microsoft
wget https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
rm packages-microsoft-prod.deb

# Instalar SDK
sudo apt update
sudo apt install dotnet-sdk-8.0
```

#### **Instalar Git**

**Windows:**

```bash
# Descargar desde: https://git-scm.com/download/win
# Ejecutar el instalador
```

**macOS:**

```bash
# Con Homebrew
brew install git

# O descargar desde: https://git-scm.com/download/mac
```

**Linux:**

```bash
# Ubuntu/Debian
sudo apt update && sudo apt install git

# CentOS/RHEL
sudo yum install git
```

#### **Instalar Make (Opcional)**

**Windows:**

```bash
# Con Chocolatey
choco install make

# Con Scoop
scoop install make
```

**macOS:**

```bash
# Ya viene instalado por defecto
```

**Linux:**

```bash
# Ubuntu/Debian
sudo apt install make

# CentOS/RHEL
sudo yum install make
```

### 1. **Obtener la Plantilla**

#### **Opci√≥n A: Clonar desde GitHub (Recomendado)**

```bash
# Clonar el repositorio
git clone https://github.com/tu-usuario/Plantilla-Micro-Servicio.git
cd Plantilla-Micro-Servicio

# O si prefieres tu propio fork
git clone https://github.com/tu-usuario/Plantilla-Micro-Servicio.git MiNuevoMicroServicio
cd MiNuevoMicroServicio
```

#### **Opci√≥n B: Usar como Template de GitHub**

1. Ve a https://github.com/tu-usuario/Plantilla-Micro-Servicio
2. Haz clic en **"Use this template"**
3. Selecciona **"Create a new repository"**
4. Dale un nombre a tu nuevo microservicio
5. Clona tu nuevo repositorio

#### **Opci√≥n C: Descargar ZIP**

1. Ve a https://github.com/tu-usuario/Plantilla-Micro-Servicio
2. Haz clic en **"Code"** ‚Üí **"Download ZIP"**
3. Extrae el archivo donde quieras
4. Renombra la carpeta a tu proyecto

### 2. **Personalizar la Plantilla**

```bash
# Copiar archivo de variables de entorno
cp env.example .env

# Editar configuraci√≥n con tu informaci√≥n
# Puedes usar cualquier editor de texto
notepad .env  # Windows
nano .env     # Linux/macOS
code .env     # VS Code
```

#### **Variables Importantes a Configurar:**

```bash
# Nombre de tu microservicio
PROJECT_NAME=MiNuevoMicroServicio

# Configuraci√≥n de base de datos
DATABASE_PROVIDER=sqlserver  # o postgres
DB_PASSWORD=TuContrase√±aSegura

# Configuraci√≥n JWT
JWT_SECRET=TuClaveSecretaMuyLargaAlMenos64Caracteres

# Puertos (cambiar si est√°n ocupados)
API_PORT=8080
DB_PORT=1433
```

#### **Renombrar Archivos (Opcional)**

Si quieres cambiar el nombre de la plantilla:

```bash
# Renombrar carpetas del proyecto
mv PlantillaMicroServicio MiNuevoMicroServicio
mv PlantillaMicroServicio.Aplication MiNuevoMicroServicio.Aplication
mv PlantillaMicroServicio.Dal MiNuevoMicroServicio.Dal
mv PlantillaMicroServicio.Infrastructure MiNuevoMicroServicio.Infrastructure
mv PlantillaMicroServicio.Models MiNuevoMicroServicio.Models

# Renombrar archivos de proyecto
mv PlantillaMicroServicio.csproj MiNuevoMicroServicio.csproj
mv PlantillaMicroServicio.Aplication.csproj MiNuevoMicroServicio.Aplication.csproj
mv PlantillaMicroServicio.Dal.csproj MiNuevoMicroServicio.Dal.csproj
mv PlantillaMicroServicio.Infrastructure.csproj MiNuevoMicroServicio.Infrastructure.csproj
mv PlantillaMicroServicio.Models.csproj MiNuevoMicroServicio.Models.csproj
mv PlantillaMicroServicio.sln MiNuevoMicroServicio.sln
```

### 3. **Inicializar el Proyecto**

#### **Opci√≥n A: Script Autom√°tico (Recomendado)**

```bash
# Dar permisos de ejecuci√≥n (Linux/macOS)
chmod +x init-project.sh

# Ejecutar script de inicializaci√≥n
./init-project.sh
```

El script te guiar√° a trav√©s de:

- ‚úÖ Configuraci√≥n del nombre del proyecto
- ‚úÖ Selecci√≥n de base de datos
- ‚úÖ Configuraci√≥n de puertos
- ‚úÖ Generaci√≥n de credenciales seguras
- ‚úÖ Renombrado autom√°tico de archivos
- ‚úÖ Despliegue inicial

#### **Opci√≥n B: Inicializaci√≥n Manual**

```bash
# 1. Levantar servicios
docker-compose up -d

# 2. Verificar que todo funcione
docker-compose ps

# 3. Ver logs
docker-compose logs api
```

### 4. **Verificar Instalaci√≥n**

```bash
# Verificar que Docker est√© funcionando
docker --version
docker-compose --version

# Verificar que los servicios est√©n corriendo
docker ps

# Ver logs de la aplicaci√≥n
docker-compose logs api
```

### 4. **Verificar Instalaci√≥n**

```bash
# Verificar que Docker est√© funcionando
docker --version
docker-compose --version

# Verificar que los servicios est√©n corriendo
docker ps

# Ver logs de la aplicaci√≥n
docker-compose logs api
```

### 5. **Acceder a los Servicios**

Una vez completado, tendr√°s acceso a:

- üåê **API**: http://localhost:8080
- üìö **Swagger**: http://localhost:8080/swagger
- üìä **Seq (Logs)**: http://localhost:5341
- üóÑÔ∏è **Base de Datos**: localhost:1433

### 6. **Comenzar a Desarrollar**

¬°Tu microservicio est√° listo! Ahora puedes:

```bash
# 1. Abrir en tu IDE favorito
code .  # VS Code
# o
dotnet open MiNuevoMicroServicio.sln  # Visual Studio

# 2. Crear tu primer endpoint
# Editar: MiNuevoMicroServicio/Controllers/TuController.cs

# 3. Agregar tu l√≥gica de negocio
# Editar: MiNuevoMicroServicio.Aplication/Feature/

# 4. Configurar tu base de datos
# Editar: MiNuevoMicroServicio.Dal/Contexto/
```

### ‚ö° **Instalaci√≥n R√°pida (Para Expertos)**

Si ya tienes Docker instalado y conoces el proceso:

```bash
# Clonar y configurar en un comando
git clone https://github.com/tu-usuario/Plantilla-Micro-Servicio.git && cd Plantilla-Micro-Servicio && cp env.example .env && ./init-project.sh
```

### üéØ **Usar como Template de GitHub**

Para hacer tu plantilla m√°s f√°cil de usar:

1. **Hacer la plantilla p√∫blica** en GitHub
2. **Agregar el bot√≥n "Use this template"**:
   - Ve a Settings ‚Üí General
   - Marca "Template repository"
3. **Los usuarios podr√°n crear repositorios** basados en tu plantilla

#### **Ventajas del Template de GitHub:**

- ‚úÖ **Crea repositorios nuevos** autom√°ticamente
- ‚úÖ **Mantiene el historial** de Git limpio
- ‚úÖ **F√°cil de usar** para otros desarrolladores
- ‚úÖ **Actualizaciones autom√°ticas** disponibles

### üîß **Instalaci√≥n Manual (Sin Script)**

Si prefieres hacerlo paso a paso:

```bash
# 1. Clonar repositorio
git clone <tu-repositorio>
cd Plantilla-Micro-Servicio

# 2. Configurar variables de entorno
cp env.example .env
# Editar .env con tus preferencias

# 3. Levantar servicios
docker-compose up -d

# 4. Verificar que todo funcione
docker-compose ps
curl http://localhost:8080/health
```

## üõ†Ô∏è Comandos √ötiles

### **Desarrollo Local**

```bash
# Ejecutar en modo desarrollo
make dev

# Construir proyecto
make build

# Ejecutar tests
make test

# Limpiar archivos de build
make clean
```

### **Docker**

```bash
# Levantar servicios
make up

# Ver logs
make logs

# Detener servicios
make down

# Reconstruir y levantar
make rebuild

# Ver estado de servicios
make status
```

### **Base de Datos**

```bash
# Acceder al shell de la BD
make db-shell

# Crear backup
make db-backup

# Restaurar backup
make db-restore BACKUP_FILE=archivo.bak
```

### **Monitoreo**

```bash
# Verificar salud de la API
make api-health

# Abrir Swagger
make api-swagger

# Abrir Seq
make logs-view
```

## üèóÔ∏è Arquitectura y Estructura

### **Clean Architecture Implementada**

Esta plantilla sigue los principios de **Clean Architecture** con una separaci√≥n clara de responsabilidades:

```
üìÅ [TuProyecto]/                    # üéØ API Layer (Presentaci√≥n)
‚îú‚îÄ‚îÄ Controllers/                    # Controladores REST
‚îú‚îÄ‚îÄ Middleware/                     # Middleware personalizado
‚îú‚îÄ‚îÄ Extensions/                     # Extensiones de configuraci√≥n
‚îî‚îÄ‚îÄ Program.cs                      # Punto de entrada

üìÅ [TuProyecto].Aplication/         # üß† Application Layer (L√≥gica de Aplicaci√≥n)
‚îú‚îÄ‚îÄ Feature/                        # Patr√≥n CQRS con MediatR
‚îÇ   ‚îú‚îÄ‚îÄ Consulta/                   # Queries (Consultas)
‚îÇ   ‚îî‚îÄ‚îÄ Comando/                    # Commands (Comandos)
‚îú‚îÄ‚îÄ Servicios/                      # Servicios de aplicaci√≥n
‚îú‚îÄ‚îÄ Mapeo/                          # AutoMapper profiles
‚îî‚îÄ‚îÄ Middleware/                     # Middleware de aplicaci√≥n

üìÅ [TuProyecto].Dal/                # üóÑÔ∏è Data Access Layer
‚îú‚îÄ‚îÄ Contexto/                       # DbContext de Entity Framework
‚îú‚îÄ‚îÄ Core/                           # Interfaces y abstracciones
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/                 # IRepository, IUnitOfWork
‚îÇ   ‚îî‚îÄ‚îÄ Repositories/               # Implementaciones
‚îî‚îÄ‚îÄ Extension.cs                    # Configuraci√≥n de DAL

üìÅ [TuProyecto].Infrastructure/     # üîß Infrastructure Layer
‚îú‚îÄ‚îÄ Authentication/                 # JWT Authentication
‚îú‚îÄ‚îÄ Logging/                        # Serilog configuration
‚îú‚îÄ‚îÄ Configuration/                  # Configuraciones externas
‚îî‚îÄ‚îÄ Extensions/                     # Extensiones de infraestructura

üìÅ [TuProyecto].Models/             # üì¶ Shared Models
‚îú‚îÄ‚îÄ Api/                            # DTOs y modelos de API
‚îú‚îÄ‚îÄ Configuracion/                  # Clases de configuraci√≥n
‚îî‚îÄ‚îÄ Entidades/                      # Entidades de dominio
```

### **Patr√≥n CQRS Implementado**

La plantilla utiliza **CQRS (Command Query Responsibility Segregation)** con MediatR:

```csharp
// Ejemplo de Query
public class VerificarEstadoConsulta : IRequest<ControlSalud>
{
    public string Servicio { get; set; }
}

public class VerificarEstadoHandler : IRequestHandler<VerificarEstadoConsulta, ControlSalud>
{
    public async Task<ControlSalud> Handle(VerificarEstadoConsulta request, CancellationToken cancellationToken)
    {
        // L√≥gica de consulta
    }
}

// Ejemplo de Command
public class CrearUsuarioComando : IRequest<int>
{
    public string Nombre { get; set; }
    public string Email { get; set; }
}
```

### **Entity Framework Core**

Configurado con **Repository Pattern** y **Unit of Work**:

```csharp
// Interfaz del repositorio
public interface IRepositorio<T> where T : class
{
    Task<T> ObtenerPorIdAsync(int id);
    Task<IEnumerable<T>> ObtenerTodosAsync();
    Task AgregarAsync(T entidad);
    Task ActualizarAsync(T entidad);
    Task EliminarAsync(T entidad);
}

// Unit of Work
public interface IPlantillaMicroServicioUoW
{
    IRepositorio<T> Repositorio<T>() where T : class;
    Task<int> GuardarCambiosAsync();
}
```

## üîß Configuraci√≥n

### **Caracter√≠sticas T√©cnicas Avanzadas**

#### **Docker Profesional**

- **Multi-stage builds** para optimizaci√≥n de im√°genes
- **Usuario no-root** para seguridad
- **Health checks** integrados
- **Variables din√°micas** para configuraci√≥n autom√°tica
- **Optimizaci√≥n de capas** para builds m√°s r√°pidos

#### **Logging y Monitoreo**

- **Serilog** con logging estructurado
- **Seq** para visualizaci√≥n de logs
- **Request/Response logging** autom√°tico
- **Error tracking** con contexto completo
- **Performance monitoring** integrado

#### **Seguridad Enterprise**

- **JWT Authentication** configurado
- **CORS profesional** por ambiente
- **Rate limiting** integrado
- **HTTPS** listo para producci√≥n
- **Secrets management** con Docker

#### **Base de Datos**

- **Entity Framework Core** configurado
- **Repository Pattern** implementado
- **Unit of Work** pattern
- **Migrations** autom√°ticas
- **Connection pooling** optimizado

### **Sistema de Variables de Entorno Profesional**

El template implementa un **sistema enterprise-grade** de variables de entorno que permite:

- ‚úÖ **Configuraci√≥n sin re-despliegue** - Cambia variables sin rebuild
- ‚úÖ **Validaci√≥n autom√°tica** - Verifica configuraci√≥n antes del despliegue
- ‚úÖ **Generaci√≥n autom√°tica** - Scripts que crean configuraciones v√°lidas
- ‚úÖ **Separaci√≥n por ambiente** - Development/Staging/Production
- ‚úÖ **Secrets management** - Manejo seguro de credenciales

### **Variables Requeridas**

```bash
# Variables CR√çTICAS (deben estar configuradas)
PROJECT_NAME=MiMicroServicio          # Nombre del proyecto
JWT_SECRET=TuClaveSecretaMuyLarga     # Al menos 64 caracteres
DB_PASSWORD=TuContrase√±aSegura        # Contrase√±a de base de datos
```

### **Variables Importantes**

```bash
# Configuraci√≥n de la aplicaci√≥n
ASPNETCORE_ENVIRONMENT=Development
DATABASE_PROVIDER=sqlserver
API_PORT=8080
DB_PORT=1433
REDIS_PORT=6379
SEQ_PORT=5341
```

### **Variables Opcionales**

```bash
# Configuraci√≥n avanzada
ASPNETCORE_KESTREL_MAX_CONNECTIONS=100
SERILOG_LEVEL=Information
CACHE_EXPIRATION_SECONDS=300
CORS_ORIGINS=http://localhost:3000
RATE_LIMIT_PER_MINUTE=100
```

## üåê Configuraci√≥n de CORS Profesional

El microservicio incluye una **configuraci√≥n de CORS profesional** que permite especificar exactamente qu√© or√≠genes, m√©todos y headers est√°n permitidos para cada ambiente.

### **Configuraci√≥n por Ambiente**

#### **Desarrollo (`appsettings.Development.json`)**

```json
{
  "ConfiguracionCors": {
    "OrigenesPermitidos": [
      "http://localhost:3000",
      "http://localhost:4200",
      "http://localhost:8080",
      "http://localhost:5173"
    ],
    "PermitirCredenciales": true,
    "MetodosPermitidos": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    "HeadersPermitidos": [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
      "Origin"
    ]
  }
}
```

#### **Producci√≥n (`appsettings.Production.json`)**

```json
{
  "ConfiguracionCors": {
    "OrigenesPermitidos": [
      "https://tu-frontend-produccion.com",
      "https://www.tu-frontend-produccion.com"
    ],
    "PermitirCredenciales": true,
    "MetodosPermitidos": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    "HeadersPermitidos": ["Content-Type", "Authorization", "X-Requested-With"]
  }
}
```

### **C√≥mo Configurar para tu Frontend**

1. **Identifica la URL de tu frontend** (ej: `https://mi-app.com`)
2. **Agrega la URL al array `OrigenesPermitidos`** en el archivo de configuraci√≥n correspondiente
3. **Reinicia el microservicio** para aplicar los cambios

### **Ventajas de esta Configuraci√≥n**

- ‚úÖ **Seguridad mejorada** - Solo or√≠genes espec√≠ficos permitidos
- ‚úÖ **Configuraci√≥n por ambiente** - Diferentes reglas para dev/prod
- ‚úÖ **F√°cil mantenimiento** - Cambios sin modificar c√≥digo
- ‚úÖ **Flexibilidad** - Control granular sobre m√©todos y headers
- ‚úÖ **Credenciales seguras** - Soporte para cookies y headers de autorizaci√≥n

### **Comandos de Configuraci√≥n**

```bash
# Configuraci√≥n r√°pida (recomendado)
./quick-setup.sh

# Configuraci√≥n manual
make env-setup
make validate-env

# Validar configuraci√≥n
./validate-env.sh
```

### **Entornos Disponibles**

#### **Desarrollo**

```bash
docker-compose up -d
```

#### **Producci√≥n**

```bash
docker-compose -f docker-compose.prod.yml up -d
```

## üê≥ Docker Compose

### **Servicios Incluidos**

| Servicio       | Descripci√≥n             | Puerto |
| -------------- | ----------------------- | ------ |
| **api**        | Microservicio principal | 8080   |
| **db**         | SQL Server              | 1433   |
| **redis**      | Cache                   | 6379   |
| **seq**        | Logging                 | 5341   |
| **nginx**      | Load Balancer (prod)    | 80/443 |
| **prometheus** | M√©tricas (prod)         | 9090   |
| **grafana**    | Dashboards (prod)       | 3000   |

### **Vol√∫menes**

- `db_data`: Datos de SQL Server
- `redis_data`: Datos de Redis
- `seq_data`: Logs de Seq
- `prometheus_data`: M√©tricas de Prometheus
- `grafana_data`: Dashboards de Grafana

## üîí Seguridad

### **Configuraci√≥n Autom√°tica**

- ‚úÖ Contrase√±as generadas autom√°ticamente
- ‚úÖ Claves JWT seguras
- ‚úÖ Usuario no-root en contenedores
- ‚úÖ Health checks implementados
- ‚úÖ Rate limiting configurado

### **Recomendaciones de Producci√≥n**

1. **Cambiar todas las contrase√±as** por defecto
2. **Configurar HTTPS** con certificados v√°lidos
3. **Usar secrets management** (Docker Secrets, Kubernetes Secrets)
4. **Configurar firewalls** apropiados
5. **Implementar backup autom√°tico** de bases de datos

## üìä Monitoreo y Logging

### **Logging Estructurado**

```csharp
// Ejemplo de logging
_logger.Information("Usuario {UserId} accedi√≥ al sistema", userId);
```

### **M√©tricas Disponibles**

- Request/response times
- Error rates
- Memory usage
- CPU usage
- Database connections

### **Dashboards Predefinidos**

- API Performance
- Error Tracking
- System Resources
- Database Metrics

## üöÄ Despliegue

### **Desarrollo Local**

```bash
# Inicializar proyecto
./init-project.sh

# O manualmente
make init
```

### **Producci√≥n**

```bash
# Configurar variables de producci√≥n
cp env.example .env
# Editar .env con valores de producci√≥n

# Desplegar
docker-compose -f docker-compose.prod.yml up -d
```

### **Escalado**

```bash
# Escalar API a 3 r√©plicas
make scale REPLICAS=3
```

## üîß Personalizaci√≥n

### **Agregar Nuevos Servicios**

1. Agregar servicio en `docker-compose.yml`
2. Configurar variables en `env.example`
3. Actualizar `Makefile` con comandos √∫tiles

### **Cambiar Base de Datos**

1. Modificar `DATABASE_PROVIDER` en `.env`
2. Actualizar connection strings
3. Cambiar imagen en docker-compose

### **Agregar Nuevas APIs**

1. Crear controladores en la capa API
2. Implementar handlers en Application
3. Agregar repositorios en Dal

## üêõ Troubleshooting

### **Problemas de Instalaci√≥n**

#### **Docker no est√° instalado o no funciona**

```bash
# Verificar instalaci√≥n
docker --version

# Si no est√° instalado, seguir instrucciones de instalaci√≥n arriba
# Si est√° instalado pero no funciona:

# Windows: Reiniciar Docker Desktop
# macOS: Reiniciar Docker Desktop
# Linux: sudo systemctl restart docker
```

#### **Puerto ya en uso**

```bash
# Ver qu√© est√° usando el puerto
netstat -ano | findstr :8080  # Windows
lsof -i :8080                 # macOS/Linux

# Cambiar puerto en .env
API_PORT=8081
```

#### **Permisos de archivo (Linux/macOS)**

```bash
# Dar permisos de ejecuci√≥n
chmod +x init-project.sh
chmod +x *.sh

# Si hay problemas con Docker
sudo usermod -aG docker $USER
# Reiniciar sesi√≥n despu√©s
```

#### **Base de datos no conecta**

```bash
# Verificar logs
make logs-db

# Reiniciar servicios
make restart

# Verificar variables de entorno
cat .env | grep DB_
```

#### **Contenedor no inicia**

```bash
# Ver logs detallados
docker-compose logs api

# Reconstruir imagen
make rebuild

# Limpiar contenedores y vol√∫menes
docker-compose down -v
docker system prune -f
```

#### **Script de inicializaci√≥n falla**

```bash
# Verificar que el archivo existe
ls -la init-project.sh

# Ejecutar con bash expl√≠citamente
bash init-project.sh

# Verificar permisos
chmod +x init-project.sh
```

#### **Problemas de red**

```bash
# Verificar que Docker tenga acceso a internet
docker run hello-world

# Si hay proxy corporativo, configurar Docker
# Windows/macOS: Docker Desktop > Settings > Resources > Proxies
# Linux: /etc/systemd/system/docker.service.d/http-proxy.conf
```

## üìö Recursos Adicionales

- [Documentaci√≥n de .NET 8](https://docs.microsoft.com/en-us/dotnet/)
- [Docker Documentation](https://docs.docker.com/)
- [Serilog Documentation](https://serilog.net/)
- [Seq Documentation](https://datalust.co/docs/)

## ü§ù Contribuci√≥n

1. Fork el proyecto
2. Crea una rama para tu feature (`git checkout -b feature/AmazingFeature`)
3. Commit tus cambios (`git commit -m 'Add some AmazingFeature'`)
4. Push a la rama (`git push origin feature/AmazingFeature`)
5. Abre un Pull Request

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT. Ver el archivo `LICENSE` para m√°s detalles.

---

## üéØ Pr√≥ximos Pasos

1. **Ejecuta el script de inicializaci√≥n**: `./init-project.sh`
2. **Personaliza la configuraci√≥n** seg√∫n tus necesidades
3. **Desarrolla tu l√≥gica de negocio** en las capas correspondientes
4. **Configura monitoreo** para producci√≥n
5. **Despliega en tu infraestructura** preferida

¬°Tu microservicio est√° listo para despegar! üöÄ
